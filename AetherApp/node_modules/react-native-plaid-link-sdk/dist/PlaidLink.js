var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var _a;
import { useEffect } from 'react';
import { NativeEventEmitter, Platform } from 'react-native';
import { LinkIOSPresentationStyle, LinkLogLevel, FinanceKitErrorType, } from './Types';
import RNLinksdkAndroid from './fabric/NativePlaidLinkModuleAndroid';
import RNLinksdkiOS from './fabric/NativePlaidLinkModuleiOS';
const RNLinksdk = (_a = (Platform.OS === 'android' ? RNLinksdkAndroid : RNLinksdkiOS)) !== null && _a !== void 0 ? _a : undefined;
/**
 * A hook that registers a listener on the Plaid emitter for the 'onEvent' type.
 * The listener is cleaned up when this view is unmounted
 *
 * @param LinkEventListener the listener to call
 */
export const usePlaidEmitter = (linkEventListener) => {
    useEffect(() => {
        const emitter = new NativeEventEmitter(RNLinksdk);
        const listener = emitter.addListener('onEvent', linkEventListener);
        // Clean up after this effect:
        return function cleanup() {
            listener.remove();
        };
    }, []);
};
export const create = (props) => {
    var _a, _b;
    let token = props.token;
    let noLoadingState = (_a = props.noLoadingState) !== null && _a !== void 0 ? _a : false;
    if (Platform.OS === 'android') {
        RNLinksdkAndroid === null || RNLinksdkAndroid === void 0 ? void 0 : RNLinksdkAndroid.createPlaidLink(token, noLoadingState, (_b = props.logLevel) !== null && _b !== void 0 ? _b : LinkLogLevel.ERROR);
    }
    else {
        RNLinksdkiOS === null || RNLinksdkiOS === void 0 ? void 0 : RNLinksdkiOS.createPlaidLink(token, noLoadingState);
    }
};
export const open = (props) => {
    if (Platform.OS === 'android') {
        RNLinksdkAndroid === null || RNLinksdkAndroid === void 0 ? void 0 : RNLinksdkAndroid.open((result) => {
            if (props.onSuccess != null) {
                props.onSuccess(result);
            }
        }, (result) => {
            if (props.onExit != null) {
                if (result.error != null && result.error.displayMessage != null) {
                    //TODO(RNSDK-118): Remove errorDisplayMessage field in next major update.
                    result.error.errorDisplayMessage = result.error.displayMessage;
                }
                props.onExit(result);
            }
        });
    }
    else {
        let presentFullScreen = props.iOSPresentationStyle == LinkIOSPresentationStyle.FULL_SCREEN;
        RNLinksdkiOS === null || RNLinksdkiOS === void 0 ? void 0 : RNLinksdkiOS.open(presentFullScreen, (result) => {
            if (props.onSuccess != null) {
                props.onSuccess(result);
            }
        }, (error, result) => {
            if (props.onExit != null) {
                if (error) {
                    var data = result || {};
                    data.error = error;
                    props.onExit(data);
                }
                else {
                    props.onExit(result);
                }
            }
        });
    }
};
/**
 * Clears any previously created Plaid session and associated resources
 * that were captured during a prior call to create(). This method should
 * be invoked before starting a new layer session with create() to ensure
 * proper cleanup and avoid conflicts from lingering state or resources.
 */
export const destroy = () => __awaiter(void 0, void 0, void 0, function* () {
    if (Platform.OS === 'android') {
        yield (RNLinksdkAndroid === null || RNLinksdkAndroid === void 0 ? void 0 : RNLinksdkAndroid.destroy());
    }
});
export const dismissLink = () => {
    if (Platform.OS === 'ios') {
        RNLinksdkiOS === null || RNLinksdkiOS === void 0 ? void 0 : RNLinksdkiOS.dismiss();
    }
};
export const submit = (data) => {
    if (Platform.OS === 'android') {
        RNLinksdkAndroid === null || RNLinksdkAndroid === void 0 ? void 0 : RNLinksdkAndroid.submit(data.phoneNumber, data.dateOfBirth);
    }
    else {
        RNLinksdkiOS === null || RNLinksdkiOS === void 0 ? void 0 : RNLinksdkiOS.submit(data.phoneNumber, data.dateOfBirth);
    }
};
/**
 * Function to sync the user's transactions from their Apple card.
 *
 * @param {string} token - The `LinkToken` your server retrieved from the /link/token/create endpoint from the Plaid API.
 *                         This token must be associated with an accessToken.
 * @param {boolean} requestAuthorizationIfNeeded - Indicates if the user should be prompted to authorize the sync if
 *                                                 they have not already done so.
 * @param {function} completion - A callback function that is called when the sync has completed.
 *
 * @warning This method only works on iOS >= 17.4.
 * @warning This method is not supported on Android or MacCatalyst.
 * @warning This method can only be used once the user has granted access to their Apple card via a standard Link Session.
 * @warning This method requires that your app has been granted FinanceKit access from Apple.
 */
export const syncFinanceKit = (token, requestAuthorizationIfNeeded, simulatedBehavior, completion) => {
    if (Platform.OS === 'android') {
        completion({
            type: FinanceKitErrorType.Unknown,
            message: "FinanceKit is unavailable on Android!",
        });
    }
    else {
        RNLinksdkiOS === null || RNLinksdkiOS === void 0 ? void 0 : RNLinksdkiOS.syncFinanceKit(token, requestAuthorizationIfNeeded, simulatedBehavior, () => {
            completion();
        }, (error) => {
            completion({
                type: error.type,
                message: error.message,
            });
        });
    }
};
